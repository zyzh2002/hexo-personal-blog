{"posts":[{"title":"SPEI计算的原理与算法优化","text":"什么是SPEI标准化降水蒸散指数SPEI（Standardized Precipitation Evapotranspiration Index）可以表征干湿状态。SPEI值越大越湿润，越小越干旱，其最早由Sergio M. Vicente-Serrano等人提出。 SPEI算法构建差值序列首先构建降水量\\(P_i\\)和潜在蒸散发\\(PET_i\\)的差值序列\\(D_i\\)， $$ D_i = P_i-PET_i $$ 可以选定不同的时间尺度来计算SPEI。时间尺度为\\(k\\)，\\(i\\)日的\\(D_i\\)累计为该日前\\(k\\)天的\\(D_i\\)之和，也就是说，对于每个\\(k\\)尺度的\\(D_i\\)，其为前\\(k\\)天的滑动窗口和。 对差值序列进行拟合目前常见的SPEI拟合方法均为使用三参数Log-Logistic分布（也称Fisk分布）对\\(D_i\\)进行拟合。近几年的研究显示，Genextreme分布对SPEI有更好的拟合效果。 Python在GIS系统中有其重要的生态位，但是使用Python对SPEI进行计算十分低效。传统方法中，若使用Scipy和循环进行Fisk分布的参数估计，计算大型数据集将十分困难，考虑如下代码： 1234567891011121314import numpy as npdef calc_spei_fisk_paras(d_i_matrix:np.ndarray) -&gt; np.ndarray: from scipy.stats import fisk d_i_shape = d_i_matrix.shape # d_i_matrix is the numpy array with the shape (time,x,y) paras = np.zeros_like(d_i_shape)[0:3,:,:] # Storage fisk distribution paras for i in d_i_shape[1]: for j in d_i_shape[2]: paras[:,i,j] = fisk.fit(d_i_matrix[:,i,j]) return paras 该函数使用二重嵌套循环对SPEI进行计算，因为Python的特性，该段代码的执行将极度缓慢，面对高分辨率图象时尤其明显。要对该算法进行优化，有以下几个方向： 循环向量化 寻找新的参数估计模式 jit编译 概率值正态化序列值代入已估计参数的Genextreme分布得到概率值$P_i$；之后将概率值代入标准正态分布累积分布函数的反函数，得到SPEI值： $$ SPEI_i = \\Phi^{-1}(P_i) $$ 算法优化循环向量化循环向量化指将使用循环进行的操作改为操作向量，C语言在编译时编译器会自动地将循环优化成处理器支持的SIMD指令。 SIMD(Single Instruction Multiple Data)即单指令流多数据流，是一种采用一个控制器来控制多个处理器，同时对一组数据（又称“数据向量”）中的每一个分别执行相同的操作从而实现空间上的并行性的技术。 考虑以下C代码， 12345678910111213141516171819202122232425/*simd.cTest the simd optimization support for gcc */#include &lt;stdio.h&gt;#define LENGTH(array) (sizeof(array) / sizeof(array[0]))int main(){ int vec1 [3]; int vec2 [3]; printf(&quot;Input the First Vec:\\n&quot;); scanf(&quot;%d%d%d&quot;,&amp;vec1[0],&amp;vec1[1],&amp;vec1[2]); printf(&quot;Input the Secound Vec:\\n&quot;); scanf(&quot;%d%d%d&quot;,&amp;vec2[0],&amp;vec2[1],&amp;vec2[2]); int vec3[3]; for(int i = 0;i&lt;LENGTH(vec1);i++){ vec3[i] = vec1[i]+vec2[i]; } printf(&quot;Sum Vector is %d %d %d\\n&quot;,vec3[0],vec3[1],vec3[2]); return 0;} 该程序将两个int类型的变量使用循环相加。在AMD64机器上使用gcc的-O1和-O3优化选项分别编译得到汇编文件： 123gcc simd.c -S -o simd_O1.S -O1 -vgcc simd.c -S -o simd_O3.S -O3 -v 我们只关注scanf调用和printf调用之间的部分，汇编文件分别为： 1234567891011# simd_O1.Scall __isoc99_scanfmovl 16(%rsp), %ecxaddl 28(%rsp), %ecxmovl 12(%rsp), %edxaddl 24(%rsp), %edxmovl 8(%rsp), %esiaddl 20(%rsp), %esimovl $.LC3, %edimovl $0, %eaxcall printf 123456789101112# simd_O3.Scall __isoc99_scanfmovl 24(%rsp), %ecxmovl $.LC3, %edixorl %eax, %eaxmovq (%rsp), %xmm0movq 16(%rsp), %xmm1addl 8(%rsp), %ecxpaddd %xmm1, %xmm0pextrd $1, %xmm0, %edxmovd %xmm0, %esicall printf 在没有使用优化的情况下，程序使用了3条addl指令，而优化过后其使用了xmm寄存器（SSE指令集）提升了计算效率。但Python解释器没有内建的SIMD支持，要解决这种问题可以使用numpy包： 1234567891011121314151617181920import numpy as npimport timeitdef sum_numpy(a:np.ndarray, b:np.ndarray) -&gt; np.ndarray: return np.sum(a + b)def sum_circulate(a:np.ndarray, b:np.ndarray) -&gt; np.ndarray: n = len(a) c = np.zeros(n) for i in range(n): c[i] = a[i] + b[i] return np.sum(c)a = np.random.rand(10000)b = np.random.rand(10000)print(timeit.timeit(lambda: sum_numpy(a, b), number=100))print(timeit.timeit(lambda: sum_circulate(a, b), number=100)) 输出结果不难预测， 120.0041359000006195860.6949793999992835 numpy版本的向量加法比循环版本快了170多倍。如果我们以数组规模和所用时间作图，我们得到以下结果： 问题规模越大，SIMD带来的加速效果越明显。但是scipy中的参数估计方法无法实现循环向量化，一次只能处理一个时间序列；而且修改scipy中的代码的成本又太高（大部分代码均由C语言写成），所以需要找新的参数估计模式。 Genextreme分布与L-momentsGenextreme分布是相对更好的SPEI拟合的候选分布。其参数估计可以简单的使用L-moments估计得到。 使用L-moments的参数估计过程可以由以下公式给出： GEV分布的CDF为 $$\\begin{equation}F(x)=\\left{ \\begin{aligned} \\mathrm{exp}(-(1-\\kappa\\frac{x-\\xi}{\\alpha})^{1/\\kappa}),\\kappa\\not= 0 \\ \\mathrm{exp}(\\mathrm{exp}(-\\frac{x-\\xi}{\\alpha})),\\kappa = 0 \\end{aligned}\\right.\\end{equation}$$ 其中\\(\\alpha,\\xi,\\kappa\\)为参数。 记L-mean，L-scale，L-skewness分别为\\(\\lambda_1,\\lambda_2,\\tau_3\\)，GEV分布的三个参数可以用如下公式近似估计： $$\\begin{equation}\\kappa =\\left{ \\begin{aligned} &amp;0.488138(\\tau_3)^{1.70839}-1.7631(\\tau_3)^{0.981824}+0.285706, 0.01\\le\\tau_3\\le 0.5 \\ &amp;0.483706(\\tau_3)^{1.679096}-1.73786(\\tau_3)^{1.008948}+0.255108, 0.5\\le\\tau_3\\le 0.95 \\end{aligned}\\right.\\end{equation}$$$$\\begin{equation}\\frac{\\alpha}{\\lambda_2}=\\left{ \\begin{aligned} &amp;1.023602813(\\tau_3)^{1.8850974}-2.95087636(\\tau_3)^{1.195591244}+1.7599614982, -0.5\\le \\kappa \\le 0.3 \\ &amp;1.5954866(\\tau_3)^{1.5816175}-3.886135(\\tau_3)^{0.89522}+2.310643, \\kappa &gt; 0.3 \\end{aligned}\\right.\\end{equation}$$$$\\begin{equation}\\frac{\\xi-\\lambda_1}{\\lambda_2}=-0.0937(\\tau_3)^4-0.2198(\\tau_3)^3+1.407(\\tau_3)^2-1.4825(\\tau_3)-0.6205, 0.01\\le\\tau_3\\le 0.95\\end{equation}$$线性矩\\(\\lambda_1,\\lambda_2,\\tau_3\\)可以使用lmoments3包中的代码修改而来。lmoments3包中的线性矩计算方法可以简单的进行修改，以实现循环向量化： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293# Here are just a few of the key codesimport numpy as npimport numba as nb # numba jit, which will be introduced next...@nb.njit(nb.float64[:, :, :](nb.float64[:, :, :], nb.int8), parallel=True, cache=True)def get_lratios_jit(x: np.ndarray, nmom: int = 5) -&gt; np.ndarray: &quot;&quot;&quot; Calculates L-moments (up to the specified order) of an array of data using Numba JIT compilation. Args: x (np.ndarray): A 3D array of data. nmom (int, optional): The order of L-moments to compute (default is 5). Returns: np.ndarray: An array containing L-moments up to the specified order. &quot;&quot;&quot; def sort_array_with_axis(x: np.ndarray, axis: int) -&gt; np.ndarray: &quot;&quot;&quot; Sorts the input array along the specified axis. Args: x (np.ndarray): Input array. axis (int): Axis along which to sort. Returns: np.ndarray: Sorted array. &quot;&quot;&quot; for i in nb.prange(x.shape[axis]): x[i] = np.sort(x[i]) return x x = np.asarray(x, dtype=np.float64) n = x.shape[0] x = sort_array_with_axis(x, 0) sum_xtrans = np.empty_like(x[0]) def comb(n, r): &quot;&quot;&quot; Computes the binomial coefficient (n choose r). Args: n (int): Total number of items. r (int): Number of items to choose. Returns: int: Binomial coefficient. &quot;&quot;&quot; if r &lt; 0 or r &gt; n: return 0 if r == 0 or r == n: return 1 c = 1 for i in range(1, r + 1): c = c * (n - i + 1) // i return c # First L-moment l1 = np.sum(x, axis=0) / comb(n, 1) if nmom == 1: return np.expand_dims(l1, axis=0) # Second L-moment comb1 = np.arange(n) coefl2 = 0.5 / comb(n, 2) sum_xtrans[:] = 0 for i in nb.prange(n): sum_xtrans += (comb1[i] - comb1[n - 1 - i]) * x[i] l2 = coefl2 * sum_xtrans if nmom == 2: return np.stack((l1, l2)) # Third L-moment comb3 = np.zeros(n) for i in range(n): comb3[i] = comb(i, 2) coefl3 = 1.0 / 3.0 / comb(n, 3) sum_xtrans[:] = 0 for i in nb.prange(n): sum_xtrans += ( comb3[i] - 2 * comb1[i] * comb1[n - 1 - i] + comb3[n - 1 - i] ) * x[i] l3 = coefl3 * sum_xtrans / l2 if nmom == 3: return np.stack((l1, l2, l3))... 由以上示例代码能计算出\\(\\lambda_1,\\lambda_2,\\tau_3\\)， 便可以由参数估计的公式给出参数值，进而描述Genextreme分布 jit编译jit 的全称是 Just-in-time，在我们使用的numba库里面则特指Just-in-time Compilation（即时编译）。因为Python的动态类型带来的低效率，需要使用jit技术加速python代码的运行。在代码第一次被执行时将被编译为高效的机器码，同时也能由编译器执行相应的编译优化，以提高执行效率。但是，numba并不是对所有的Python代码都有优化效果，使用前需要去numba的官方文档查看他支持的python功能和numpy功能。 在上一节中给出的代码就包含了numba包， 123456import numpy as npimport numba as nb # &lt;- numba jit...@nb.njit(nb.float64[:, :, :](nb.float64[:, :, :], nb.int8), parallel=True, cache=True) # &lt;- decoratordef get_lratios_jit(x: np.ndarray, nmom: int = 5) -&gt; np.ndarray: ... 注意到使用了@njit函数装饰器，装饰器的参数里给出了输入输出数组的数据类型，以及parallel=True，cache=True等几个选项。他们的意义分别是开启自动循环并行化和编译缓存。这里将仅解释循环并行化，也可以看官方对循环自动并行化的解释。 循环并行化假设代码在一个多CPU系统上运行，对于类似下文给出的没有交叉迭代以来关系的循环， 12345678910@njit(parallel=True)def test(x): n = x.shape[0] a = np.sin(x) b = np.cos(a * a) acc = 0 for i in prange(n - 2): for j in prange(n - 1): acc += b[i] + b[j + 1] return acc numba会自动将循环分配到CPU的多个核心上以增加并行度。 后记文中的完整代码以放于Github仓库pylm-spei。要在正态化的步骤执行加速，可以参考numba-stats。","link":"2024/04/15/SPEI%E8%AE%A1%E7%AE%97%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96/"},{"title":"使用docker compose搭建wordpress博客","text":"引言前几天嫖了华为云的HECS新用户优惠，69块钱就能上1c2G1M的服务器一年。手里刚好有ICP备案好的域名，就打算把原来部署在Netlify上的静态网站撤掉，把博客慢慢迁移到华为云上。 架构设计考虑到这台HECS使用了新用户优惠，续费的时候不一定有这种价格，可以考虑使用docker compose构建架构以实现方便迁移。整个架构有三个容器，wordpress，mysql和nginx，其中wordpress使用php-fpm的版本。 前期准备安装DockerHECS服务器系统使用CentOS Stream 9。 设置仓库123$ sudo dnf install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 选用阿里云的镜像源： 123sudo yum-config-manager \\ --add-repo \\ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 如果你的服务器位于境外，使用官方镜像源也许更快： 123sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 安装 Docker Engine-Community1sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin 启用docker服务1sudo systemctl enable docker --now 测试1234[root@hecs-166145 wordpress]# docker -vDocker version 25.0.3, build 4debf41[root@hecs-166145 wordpress]# 构建项目项目的目录结构如下： 1234567891011.├── compose.yml├── data│ ├── mysql│ └── wordpress├── nginx│ └── wordpress.conf└── tls_certs ├── ffdhe2048.txt ├── fullchain.pem └── privkey.pem compose.yml是docker compose配置文件；data/目录里存放wordpress和mysql的数据文件；nginx/是nginx的配置目录；tls_certs/里存放了tls证书。 配置docker composecompose.yml有如下内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253version: '3'services: wordpress: image: wordpress:6.4.3-php8.3-fpm-alpine container_name: wordpress restart: always environment: WORDPRESS_DB_HOST: 'mysql' WORDPRESS_DB_USER: 'wdpress' WORDPRESS_DB_PASSWORD: 'YOUR_PASSWORD' WORDPRESS_DB_NAME: 'wd' volumes: - ./data/wordpress:/var/www/html networks: brg: ipv4_address: 192.168.234.2 nginx: image: nginx:alpine container_name: nginx volumes: - ./nginx:/etc/nginx/conf.d - ./tls_certs:/etc/sslcerts - ./data/wordpress:/var/www/html ports: - 80:80 - 443:443 restart: always networks: brg: ipv4_address: 192.168.234.3 mysql: image: mysql:8.3.0-oraclelinux8 container_name: mysql environment: MYSQL_DATABASE: 'wd' MYSQL_USER: 'wdpress' MYSQL_PASSWORD: 'YOUR_PASSWORD' MYSQL_RANDOM_ROOT_PASSWORD: '1' volumes: - ./data/mysql:/var/lib/mysql restart: always networks: brg: ipv4_address: 192.168.234.4networks: brg: ipam: driver: default config: - subnet: &quot;192.168.234.0/24&quot; 其中定义了3个容器和1个网络。需要注意的是，wordpress容器中的/var/www/html目录被映射到./data/wordpress，同时该目录被映射到nginx容器中。注意容器的tag，更新容器的时候需要选定同类型的版本。 配置nginx推荐使用Mozilla SSL Configuration Generator来生成适合你的SSL配置。本文中的配置文件在其生成的配置文件基础上修改而来。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# generated 2024-02-26, Mozilla Guideline v5.7, nginx 1.17.7, OpenSSL 1.1.1k, intermediate configuration# https://ssl-config.mozilla.org/#server=nginx&amp;version=1.17.7&amp;config=intermediate&amp;openssl=1.1.1k&amp;guideline=5.7server { listen 80; listen [::]:80; location / { return 301 https://$host$request_uri; }}server { listen 443 ssl http2; listen [::]:443 ssl http2; server_name YOUR_SERVER_NAME; root /var/www/html; index index.php; ssl_certificate /etc/sslcerts/fullchain.pem; ssl_certificate_key /etc/sslcerts/privkey.pem; ssl_session_timeout 1d; ssl_session_cache shared:MozSSL:10m; ssl_session_tickets off; # curl https://ssl-config.mozilla.org/ffdhe2048.txt &gt; /path/to/dhparam ssl_dhparam /etc/sslcerts/ffdhe2048.txt; # intermediate configuration ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:DHE-RSA-CHACHA20-POLY1305; ssl_prefer_server_ciphers off; # HSTS (ngx_http_headers_module is required) (63072000 seconds) add_header Strict-Transport-Security &quot;max-age=63072000&quot; always; # OCSP stapling ssl_stapling on; ssl_stapling_verify on; # replace with the IP address of your resolver resolver 223.5.5.5; location / { try_files $uri $uri/ /index.php?$args; } location ~ \\.php$ { try_files $uri =404; fastcgi_split_path_info ^(.+\\.php)(/.+)$; fastcgi_pass 192.168.234.2:9000; fastcgi_index index.php; include fastcgi_params; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param PATH_INFO $fastcgi_path_info; }} 该配置文件已经实现了伪静态，无需更多配置。记得将下一节中配置的TLS证书写进配置文件中。 使用acme.sh配置TLS证书acme.sh 实现了 acme 协议， 可以从 letsencrypt 生成免费的证书。 安装acme.sh使用官方的安装脚本安装acme.sh: 1curl https://get.acme.sh | sh -s email=my@example.com 如果你的服务器在中国境内，可以使用gitee上的仓库安装acme.sh: 123git clone https://gitee.com/neilpang/acme.sh.gitcd acme.sh./acme.sh --install -m my@example.com 申请并安装证书推荐使用dns安装方式。参考https://github.com/acmesh-official/acme.sh/wiki/dnsapi 。将证书安装到./tls_certs中，并更改相应名称。别忘了将你的域名指向你的站点，特别的，如果你的服务器位于中国大陆，要开启80和443端口需要ICP备案，请确认备案状态再进行测试。 启动要启动配置好的docker compose，运行以下命令： 1docker compose up 观察输出日志，直接使用域名访问服务器的443端口，进行初步配置。 如果要让服务以后台运行，可以添加参数： 1docker compose up -d 容器就能后台运行并在服务器启动时自动启动。 小结本部分中使用docker compose搭建了wordpress站点，并配置了TLS。下一节中将对其配置CDN访问以节省流量和防御攻击。","link":"2024/02/27/%E4%BD%BF%E7%94%A8docker-compose%E6%90%AD%E5%BB%BAwordpress%E5%8D%9A%E5%AE%A2/"}],"tags":[],"categories":[],"pages":[]}